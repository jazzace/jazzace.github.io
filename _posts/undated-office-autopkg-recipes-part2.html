---
layout: post
title: AutoPkg Recipe Writing Principles, Part 2
---
<!--
<h3>Versioning</h3>
<p>Management systems need to determine whether to install an updated version of an app on the client. The easiest way is usually to use version numbers (assuming the vendor is nice enough to make version numbers that increment). So the next thing these recipe sets may want to do is determine the version number. These three take different paths:</p>
<table>
	<thead>
	<tr> <th></th>	<th>Collects Via</th>	<th>Source</th>	<th>Format</th> </tr>
	</thead>
	<tbody>
	<tr> <th>core</th>	<td>Custom Processor</td>	<td>Microsoft AutoUpdate XML</td>	<td>16.x.build</td> </tr>
	<tr> <th>rtrouton</th>	<td>Core processors</td>	<td>pkg contents</td>	<td>16.x.build</td> </tr>
	<tr> <th>arubdesu</th>	<td>Custom Processor</td>	<td>macadmins.software XML</td>	<td>16.x.x</td> </tr>
	</tbody>
</table>
<p>Both the core and arubdesu recipes use their custom processor code to also retrieve the version number (albeit in different ways). In contrast, the rtrouton recipes get version information by unpacking the installer, collecting the version information, then disposing of the unpacked installer; this is all done using existing core processors.</p>
<!-- combine above and below-->
<p>Since the core and arubdesu recipes each used a custom processor to determine what to download, it makes sense that they use the same processor to add the versioning. The same MAU XML file that let the core recipes determine the download link also has a version number field in a format where the last number of the triad is the build number. Since that meets most people’s needs of an incrementing version number, the core recipes use this value. The arubdesu recipes make a slightly different decision in that they want the version number to match the number Microsoft uses in its documentation online (i.e. 16.28.0, not 16.28.19081202).

The core recipes can extract the version number of the download quite easily from that MAU feed in a format where the last number of the triad is a build number.

-->

<!-- Versioning
<p>The XML file that MAU (and the custom processor for the core Office recipes) uses makes the version number of the download available quite easily if you are willing to accept the last number of the triad as the build number (i.e. 16.x.buildNumber) rather than the normal public-facing format (16.x.x). While you could extract the public version number from one of the fields, this number meets the requirements of most Mac administrators in that build numbers should be unique and should get (reliably) larger as later versions are released.</p>


<p>With regards to versioning, the two recipes take different approaches. The arubdesu recipes use a custom processor to grab the version number (16.x.x) from the aforementioned XML feed. The rtrouton recipes do not use any custom processors, so the download recipe does not deal with retrieving the version number. It deals with this in the .pkg recipe by unpacking the installer, grabbing the 
A sidebar here: If you’re writing a custom processor, it makes sense to grab any information you need in one processor 

-->

<!-- recipes: Custom Processor with human-readable options (might mention updates only here);
     arubdesu: minimal custom processor with important input keys;
     rtrouton: no custom processor at all (uses arubdesu for Suite).
     
Use of Input Keys is a distraction to this point, so cover it later. Skip ahead to fact that download is a pkg and none of the recipes leave it alone.
They don't because they can't; URLDownloader successfully handles the redirect, but doesn't update the filename to match what it would have retrieved from a browser. I filed issue #432 as a feature request.
-->

<p>Often, when we download installers from a vendor, they are a pkg wrapped in a disk image. 
Microsoft does not wrap their packages, choosing instead to provide the installer package as is. That begs the question: should a recipe author categorize the recipe that downloads such a package as a <code>.download</code> or a <code>.pkg</code> recipe? Using <code>.download</code> in that instance appears to be more common, but it is easy to make an argument the other way — there is no one right answer. The Core AutoPkg recipes and the arubdesu recipes choose <code>.download</code>, while the rtrouton recipes choose to limit the download recipe to just downloading the product and then add a <code>.pkg</code> recipe as a child of that download recipe that gathers version information about the installer that was just downloaded. It is common to see manipulation of the package name in the <code>.pkg</code> recipe (usually to add version information) and limit the <code>.download</code> recipe to grabbing the product and verifying the code signature.<a href="#foot1" id="ref¥"><sup>[¥]</sup></a> But if you’re not writing a <code>.pkg</code> recipe, you can certainly defend doing it all at the same time. If I was drafting these recipes from scratch, I’d probably separate them as the rtrouton recipes have.</p>
<p> What I found interesting is that none of the download recipes leave the Microsoft-supplied filename for the package alone. Referring back to our PowerPoint example:</p>
<table>
	<thead>
	<tr> <th></th>	<th>Core AutoPkg</th>	<th>arubdesu</th>	<th>rtrouton</th> </tr>
	</thead>
	<tbody>
	<tr> <th>Microsoft Pkg Name</th> <td>Microsoft_PowerPoint_16.16.18091001_Updater</td>	<td colspan=2>Microsoft_PowerPoint_16.16.18091001_Installer</td> </tr>
	<tr> <th>Download recipe Pkg Name</th> <td>MSPowerPoint2016-16.16.18091001</td>	<td>Microsoft PowerPoint-16.17.0</td>	<td>Microsoft_PowerPoint</td> </tr>
	<tr> <th>Pkg Recipe Pkg Name</th> <td>n/a</td>	<td>n/a</td>	<td>Microsoft_PowerPoint_16.16.18091001</td> </tr>
	</tbody>
</table>
<p>This reveals another truism of AutoPkg recipe authoring: people author (and share) recipes that do what they need them to do. If others use them or build upon them, that’s great. If you need it to do something else, build your own or adapt an existing recipe. This explains the completely different naming conventions we see here. You can get pretty close to the original Microsoft naming convention with these recipes, but you cannot match it, regardless of your overrides. If that’s important to you, recipe writing and/or a pull request is in your future.</p>
<h3>Versioning</h3>
<p>All three recipes handle determining the version of their downloads differently. It is a really interesting study of different AutoPkg authoring techniques. Because it’s  </p>
<hr/>
<p id="foot¥">[¥] Many authors also use download recipes to gather version information for use in their management systems. In cases where the download processor (e.g., URLDownloader) or the recipe’s custom processor don’t provide this information “for free,” I prefer to put that versioning in the child recipe that requires it. This is essentially what Rich Trouton did in this instance. Nevertheless, there are plenty of people who believe that the versioning should be made available to all child recipes, so they include it with the download recipe. <a href="#ref¥">[Return to main text]</a></p>