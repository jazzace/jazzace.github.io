---
layout: post
title: AutoPkg Recipe Writing Principles using Office, Part 1
---
<p>In <a href="/2018/09/16/office-autopkg-recipes.html" target="_blank">previous</a> <a href="/2019/05/18/office-autopkg-recipes-update.html" target="_blank">posts</a>, I have written a fair bit about the various AutoPkg recipes for Microsoft Office. When researching those posts, I realized that the variety of approaches used for Office provided a great case study in recipe authoring techniques and deserved a post or two of its own. I discussed a few of my learnings in my <a href="/2019/05/18/office-autopkg-recipes-update.html" target="_blank">most recent post on the subject</a> and in my <a href="https://github.com/jazzace/autopkg-level-up" target="_blank">talk at the 2018 MacAdmins Conference at Penn State</a>, but this aims to take a deeper dive.</p>
<h3>The Basics</h3>
<p>There is a wealth of information in the <a href="https://github.com/autopkg/autopkg/wiki" target="_blank">AutoPkg Wiki</a> on recipe authorship, so there is no need to duplicate that here. However, a few principles therein are worth highlighting for the purpose of this discussion:</p>
<ul><li>One of the founding principles of AutoPkg is that recipes are to be “shared with others.”<a href="#foot1" id="ref1"><sup>[1]</sup></a> This is one of the main reasons we write chains of recipes (rather than monolithic ones) — we can build on the work of others and vice versa.</li>
<li>In general, a download recipe “only downloads a product and does no further processing” (other than verifying the Code Signature of the downloaded product).<a href="#foot2" id="ref2"><sup>[2]</sup></a></li>
<li>Recipe repos in the AutoPkg project “should contain your own recipes only, not be a fork of an existing repo.”<a href="#foot3" id="ref3"><sup>[3]</sup></a> So submit pull requests if you want changes to an existing recipe, or maintain a fork in a personal repo outside of the project.</li>
</ul>
<p>There is also one (often unspoken) principle that is also very important to understand, to which I alluded in my previous post:</p>
<ul><li>Recipe authors write recipes in a way that meets their particular needs (and skills).</li></ul>
<p>To make this discussion of recipes authoring techniques a little easier to follow, I'm going to focus on one recipe chain from each of the sets I have been discussing. Specifically:</p>
<ul><li>The core AutoPkg recipes [<a href="https://github.com/autopkg/recipes" target="_blank">github.com/autopkg/recipes</a> in the <a href="https://github.com/autopkg/recipes/tree/master/MSOfficeUpdates" target="_blank">MSOfficeUpdates</a> folder];</li>
<li>Rich Trouton’s recipes [<a href="https://github.com/autopkg/rtrouton-recipes" target="_blank">github.com/autopkg/rtrouton-recipes</a> in product-specific folders whose name starts with “Microsoft” or “Office”, with child recipes for Munki from Ben Toms in the <a href="https://github.com/autopkg/datajar-recipes" target="_blank">datajar-recipes repo</a>], excluding the recipes for the full Office Suite;</li>
<li>The “SKUless” recipes in Allister Banks’ personal (non-project) GitHub repo [<a href="https://github.com/arubdesu/office-recipes" target="_blank">github.com/arubdesu/office-recipes</a>].</li>
</ul>
<p>In my previous articles, I referred to these as the core, rtrouton, and arubdesu recipes respectively, so I will continue that usage here. However, you will notice that I have added significant qualifiers when I specified which recipes are being referenced, primarily to keep the discussion tidier. I am only referring to the SKUless recipes in the arubdesu/office-recipes (the ones designed to download the entire suite) because they offer an approach that is different than the other two major recipe sets and thus are useful for study. (The remainder of that repo is a smörgåsbord of different techniques, sharing code in some cases with the core recipes.) Conversely, I’ve taken the rtrouton Office Suite recipes out of the mix because they are essentially rebranded arubdesu SKUless recipes; the product-specific recipes have a unified approach that is different than the Suite and the core recipes. So with those qualifiers out of the way, let’s start our deep dive with the download recipes.</p>
<h3>Downloading and Processors</h3>
<p>The most common workflow we would see in any download recipe is:</p>
<ol><li>Determine the URI of the item we want to download;</li>
<li>Download a copy of the item (if we don’t have it already);</li>
<li>Check the code signature of the downloaded item.</li>
</ol>
<p>The recipes for Office all conform to that. They also do the right thing by inserting an <code>EndOfCheckPhase</code> processor in-between Steps 2 and 3 to properly handle running the recipe with the <code>-c</code> or <code>--check</code> option. The difference is that the core AutoPkg recipes use a custom-built processor to determine the download, and the arubdesu (SKUless) and rtrouton recipes use a core AutoPkg processor. 
What are some of the advantages and disadvantages to using a custom processor over core processors (and vice versa)?</p>
<table>
	<thead>
	<tr> <th></th>	<th>Custom Processor</th>	<th>Core Processors</th> </tr>
	</thead>
	<tbody>
	<tr valign=top> <th>Advantages</th> 
		<td><ul>
			<li>Can deal with complex/unique download and/or versioning situations</li>
			<li>Customized for that product</li>
			<li>Can be coded to use human-friendly Input values</li>
			<li>Can be more efficient</li>
			<li>Allows addition of features not currently covered by core processors</li>
		</ul></td>
		<td><ul>
			<li>Processors have already been vetted by hundreds of users</li>
			<li>Processors are well-documented (including changes) and perform common tasks</li>
			<li>Recipe author does not need to be able to code in Python</li>
			<li>Easier to audit recipes for trust (especially if you don’t know Python)</li>
		</ul></td>
	</tr>
	<tr valign=top> <th>Disadvantages</th> 
		<td><ul>
			<li>Requires knowledge of Python to write a custom processor</li>
			<li>Requires knowledge of Python or a good testing scheme to audit a custom processor for trust</li>
			<li>If you can’t write Python and the custom processor requires an update, you have to wait for someone else to do it</li>
		</ul></td>	
		<td><ul>
			<li>Limited by what existing processors can do</li>
			<li>May require extra steps to do the same thing as a custom processor does (if possible at all)</li>
			<li>Often less efficient, code-wise (if you care about such things)</li>
		</ul></td>
	</tr>
	</tbody>
</table>
<blockquote>
Sidebar: While not applicable in this case, there is another variety of processor called a Shared Processor. It is a custom processor (usually general-purpose in nature) that is not part of the Core processors but is posted in GitHub and meant to be shared in a similar fashion. Its advantages and disadvantages sit between Core and Custom. For more information on Shared Processors, <a href="https://github.com/autopkg/autopkg/wiki/Processor-Locations" target="_blank">see the AutoPkg wiki.</a>
</blockquote>

<p>In this case, the reason to use a custom or core processor boiled down to the source each set of recipes used to determine the location of the desired download.</p>

<h3>What’s Your Source?</h3>
<p>When writing AutoPkg recipes, we want to get as an authoritative source as possible for our downloads (and versioning, for that matter). If the application has an updating mechanism built in, our recipes are less likely to break if we use the same data source as that mechanism. This explains the presence of the GitHubReleasesInfoProvider and SparkleUpdateInfoProvider in the core processors. Both of those parse an update feed which will provide appropriate download links and version information for those downloads hosted by GitHub or managed by Sparkle respectively. Microsoft rolls their own update mechanism: Microsoft AutoUpdate (MAU).</p>
<p>The core recipes figured out how to parse the same feed that MAU uses in order to download the software requested by the user — definitely an authoritative source. Using this feed gave the authors a lot of flexibility in supporting test builds such as Insider Slow and Insider Fast. Basically, as long as the processor authors were willing to write the code to support selecting those options via Input variables, users could access them with AutoPkg. This accounts for the large number of lines of code in the core recipes’ processor. This also gives the recipe user the most straightforward usage: they can use a combination of meaningful words like “Production”, “latest”, and “Excel2019” as input values to direct what to download. While the original Office 2011 recipes focussed on updaters (expecting that you would be manually downloading the full installer from your volume license portal and deploying that first), the current set of recipes supports downloading full installers for the most common individual apps. (A <a href="/2019/05/18/office-autopkg-recipes-update.html#recipechart" target="_blank">full chart</a> is available in my previous post.)</p>
<p>The rtrouton and arubdesu recipes use a different source, but arguably just as authoritative. Microsoft has assigned a number to each product in its arsenal (called an FWLink), such that if you type <code>https://go.microsoft.com/fwlink/?linkid=</code> and then the appropriate 6- or 7-digit FWLink number into your browser, it will download the installer for the most current version of the appropriate product.<a href="#foot4" id="ref4"><sup>[4]</sup></a> The rtrouton and arubdesu recipes leverage this. This came in handy during the transition to Office 365/2019, where new FWLink numbers came into existence and existing numbers may not have been pointing to the variant (2016 or 365/2019) that you needed or expected. With the arubdesu SKUless recipes (the rtrouton recipes did not yet exist), you could just change one input key in your override to download the correct product. In contrast, the core recipes required code changes to the custom processor.</p>
<p>The other advantage to the “core processor with input variable” approach in this case is that you can write just one download recipe for all Microsoft products and then ask users to specify the correct FWLink number as an input variable in their override(s). Personally, I don’t want to maintain 15 recipes when 1 (with 15 overrides) will do, but I do understand that there are workflows where the separate recipe approach is valuable. That approach also improves discoverability when others search for recipes and does not require that other users determine the correct FWLink number, since it’s already in the recipe. This is the approach the rtrouton recipes take.</p>
<p>Regardless, both the core recipes and rtrouton recipes use a template from which they build all of their product-specific recipes. For the core recipes, that generic recipe is actually in the repo as <a href="https://github.com/autopkg/recipes/blob/master/MSOfficeUpdates/MSOfficeMacProduct.download.recipe" target="_blank">MSOfficeMacProduct.download.recipe</a>.</p>
<p>I am going to conclude this section with a confession: I have my own generic download recipe for Office named <a href="https://github.com/autopkg/jazzace-recipes/blob/master/Microsoft/MicrosoftMacProductFWLink.download.recipe" target="_blank">MicrosoftMacProductFWLink.download.recipe</a>. I’m 

<hr/>
<p id="foot1">[1] Reference: ReadMe of the the <a href="https://github.com/autopkg/autopkg" target="_blank">AutoPkg project repo</a>, Line 21, as well as the Introduction page of the <a href="https://github.com/autopkg/autopkg/wiki" target="_blank">AutoPkg project Wiki</a>. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] Reference: <a href="https://github.com/autopkg/autopkg/wiki/Recipe-Naming-Conventions" target="_blank">Recipe Naming Conventions page of</a> the <a href="https://github.com/autopkg/autopkg/wiki" target="_blank">AutoPkg project Wiki</a>. The part in parenthesis did not appear in the previous revision of that wiki page; I added it during the preparation of this post after confirming that the download recipes from the project’s core recipes repo had generally adopted this principle. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] Reference: <a href="https://github.com/autopkg/autopkg/wiki/Sharing-Recipes" target="_blank">Sharing Recipes page of</a> the <a href="https://github.com/autopkg/autopkg/wiki" target="_blank">AutoPkg project Wiki</a>. <a href="#ref3">[Return to main text]</a></p>
<p id="foot4">[4] People have argued that the MAU feed is a better “source” than the FWLink numbers, but I find them to be equally authoritative. FWLink numbers are incredibly stable (they only seem to need attention around a major version change, like we saw from Office 2016 to 2019) and can be found on Microsoft’s site <a href="https://docs.microsoft.com/en-ca/officeupdates/update-history-office-for-mac" target="_blank">if you search around</a>. One should not conflate the fact that many Mac Admins refer to a <a href="https://macadmins.software" target="_blank">manually-maintained web site</a> (by Paul Bowden of Microsoft, as a courtesy to our community) with the fact that FWLink numbers are fully supported by Microsoft. I would agree, however, that scraping the macadmins.software home page to determine the download link (using the URLTextSearcher processor) would be one level less authoritative, since it’s a manually-maintained page that is not on Microsoft’s web site. Sometimes, we write recipes with less-authoritative sources because there is no choice, but this is not one of those situations. <a href="#ref4">[Return to main text]</a></p>

<!--
using AutoPkg and your management system to update it after that. Microsoft’s installers have evolved a lot since then, becoming more flexible for different deployment scenarios, so the core recipes now support downloading full installers. But as I mentioned in an earlier article, it took some time for core recipes to be updated for 2019, the custom processor work being the greatest impediment. This was a repeat of what happened in the transition from Office 2011 to 2016.</p>
<p>Basically, the reason we have the three series of recipes is because different people needed different things at different times. As I recall the timeline:</p>
<ul><li>Office 2011 update recipes created for core recipes repo.</li>
<li>Office 2016 released with the ability to download full installers for individual apps and the Suite without going to a special portal.</li>
<li>Community effort made to develop new Office 2016 recipes that download full installers, hosted on GitHub by Allister Banks (first in arubdesu/microsoft-recipes, then /office-recipes).</li>
<li>The completed recipes are moved to the arubdesu-recipes in the main AutoPkg project.</li>
<li>Allister Banks and Tim Sutton spearhead an effort to get back to a single set of recipes; a new set of 2016 recipes in the style of the 2011 recipes is released in the core repo and all but the full suite installer recipes were withdrawn from the arubdesu-recipe repo.</li>
<li>People who wanted to continue using the full installer recipes did so (they were still available on GitHub in the arubdesu/office-recipes repo, so you wouldn’t find them using <code>autopkg search</code>).
<li>Office 2019/365 released.</li>
<li>Various efforts were made to create 2019 recipes and patch 2016 recipes to work with the newer recipes. (Since the primary maintainer of the core Office recipes was not deploying the new product, the core repo was not yet being updated.)</li>
<li>The most popular of the new variants was a series of recipes by Rich Trouton (rtrouton). It became the third standard (after core and arubdesu).</li>
<li>I wrote a blog post to sort out the confusion.</li>
<li>Office 2019 core recipes updated.</li>
<li>Additional functionality added to core recipes to support full installer downloads.</li>
<li>Recipes in the arubdesu/office-recipes repo updated to support Office 2019 and 365, including correct versioning.</li>
<li>After another blog post by me, rtrouton recipes updated to fill in any product coverage gaps.</li>
</ul>

If you’re using recipes in the rest of the repo, you’re probably doing so because you’ve been using those recipes for a long time and the results suit you. Anyone just starting out with AutoPkg right now would probably be best to choose either the core or rtrouton recipes unless they are really stuck on one of the features of the office-recipes mélange. Regardless

<p>On top of this, most deployment workflows require gathering version information to be used in your software management system (e.g., Munki, Jamf Pro, Filewave). All of these recipe sets do this, but once again they take different approaches. Breaking it down:</p>

He also manually maintains an XML feed that lists all the latest installers and the requisite version numbers.   

Same with the XML feed. 

-->

<!-- <p>The MSOfficeMacURLandUpdateInfoProvider.py processor (used in the core Office recipes) is 337 lines; the OfficeSuiteSKULessVersionProvider.py processor (used in the arubdesu recipes) is 66. Why the discrepancy? There’s lots to unpack when we look at the code.</p> -->
